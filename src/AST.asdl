-- Abstract Syntax Tree
--
-- The AST is generated by parse() from the concrete syntax in Empirical.g4.
-- ASDL converts this file into an abstract Visitor class.

module AST
{
  mod = Module(stmt* body, string? docstring)

  stmt = FunctionDef(identifier name, declaration* templates,
                     declaration* args, stmt* body, expr? single,
                     bool force_inline, expr? explicit_rettype,
                     string? docstring)
       | GenericDef(stmt original, declaration* placeholders,
                    declaration* args, expr? explicit_rettype)
       | MacroDef(stmt original, declaration* args, expr? explicit_rettype)
       | TemplateDef(stmt original, declaration* templates)
       | DataDef(identifier name, declaration* templates, declaration* body,
                 expr? single)
       | Return(expr? value)
       | If(expr test, stmt* body, stmt* orelse)
       | While(expr test, stmt* body)
       | Import(alias* names)
       | ImportFrom(identifier module, alias* names)
       | Decl(decltype dt, declaration* decls)
       | Assign(expr target, expr value)
       | Del(expr* target)
       | Expr(expr value)

  expr = Query(expr table, querytype qt, alias* cols, alias* by, expr? where)
       | Sort(expr table, alias* by)
       | Join(expr left, expr right, alias* on, alias? asof, bool strict,
              direction direction, expr? within)
       | UnaryOp(identifier op, expr operand)
       | BinOp(expr left, identifier op, expr right)
       | FunctionCall(expr func, expr* args)
       | Member(expr value, identifier member)
       | Subscript(expr value, slice slice)
       | UserDefinedLiteral(expr literal, identifier suffix)
       | IntegerLiteral(int64_t n)
       | FloatingLiteral(double n)
       | BoolLiteral(bool b)
       | Str(string s)
       | Char(char c)
       | Id(identifier s)
       | TemplatedId(expr id, expr* templates)
       | List(expr* values)
       | Paren(expr subexpr)
       | AnonData(declaration* body)

  slice = Slice(expr? lower, expr? upper, expr? step)
        | Index(expr value)

  alias = (expr value, identifier? name)

  declaration = (identifier name, expr? explicit_type, expr? value,
                 bool macro_parameter)

  decltype = Let | Var

  querytype = Select | Exec

  direction = Default | Backward | Forward | Nearest
}
