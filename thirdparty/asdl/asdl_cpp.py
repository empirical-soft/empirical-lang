#!/usr/bin/env python
"""Generate C++ code from an ASDL description."""

import os
import sys

import asdl

TABSIZE = 4
MAX_COL = 80


def get_c_type(name):
    """Return a string for the C name of the type.

    This function special cases the default types provided by asdl.
    """
    if name == "string":
        return "std::string"
    elif name in asdl.builtin_types:
        return name
    else:
        return "%s_t" % name


def is_simple(sum):
    """Return True if a sum is a simple.

    A sum is simple if its constructors have no fields, e.g.
    unaryop = Invert | Not | UAdd | USub
    """
    for c in sum.cons:
        if c.fields:
            return False
    return True


def get_args(fields):
    """Return list of C argument info, one for each field.

    Argument info is 3-tuple of a C type, variable name, and flag
    that is true if type can be NULL.
    """
    args = []
    unnamed = {}
    for f in fields:
        if f.name is None:
            name = f.type
            c = unnamed[name] = unnamed.get(name, 0) + 1
            if c > 1:
                name = "name%d" % (c - 1)
        else:
            name = f.name
        ctype = get_c_type(f.type)
        if f.seq:
            ctype = "std::vector<%s>" % ctype
        if ctype.startswith("std::") or ctype == "identifier":
            ctype = "const " + ctype + "&"
        args.append((ctype, name, f.opt or f.seq))
    return args


def reflow_lines(s, depth):
    """Reflow the line s indented depth tabs.

    Return a sequence of lines where no line extends beyond MAX_COL
    when properly indented.  The first line is properly indented based
    exclusively on depth * TABSIZE.  All following lines -- these are
    the reflowed lines generated by this function -- start at the same
    column as the first character beyond the opening { in the first
    line.
    """
    size = MAX_COL - depth * TABSIZE
    if len(s) < size:
        return [s]

    lines = []
    cur = s
    padding = ""
    while len(cur) > size:
        i = cur.rfind(' ', 0, size)
        assert i != -1, "Impossible line %d to reflow: %r" % (size, s)
        # XXX make sure we aren't in a quotation
        if cur[:i].count('"') % 2 == 1:
            i = cur.rfind('"', 0, i) - 1
        lines.append(padding + cur[:i])
        if len(lines) == 1:
            # find new size based on brace
            j = cur.find('{', 0, i)
            if j >= 0:
                j += 2  # account for the brace and the space after it
                size -= j
                padding = " " * j
            else:
                j = cur.find('(', 0, i)
                if j >= 0:
                    j += 1  # account for the paren (no space after it)
                    size -= j
                    padding = " " * j
        cur = cur[i+1:]
    else:
        lines.append(padding + cur)
    return lines


class EmitVisitor(asdl.VisitorBase):
    """ Emit lines to the object file """

    def __init__(self, file):
        self.file = file
        super(EmitVisitor, self).__init__()

    def emit(self, s, depth, reflow=True):
        if reflow:
            lines = reflow_lines(s, depth)
        else:
            lines = [s]
        for line in lines:
            line = (" " * TABSIZE * depth) + line + "\n"
            self.file.write(line)


class NamespaceVisitor(EmitVisitor):
    """ Emits namespace for a module """

    def visitModule(self, mod):
        self.emit("namespace %s {" % mod.name, 0)
        self.emit("", 0)
        self.emit('typedef std::string identifier;', 0)


class TypeDefVisitor(EmitVisitor):
    """ Emit enums for simple sums and typedefs for everything else """

    def visitModule(self, mod):
        self.emit("class BaseVisitor;", 0)
        self.emit("", 0)
        for type in mod.types:
            self.visit(type)

    def visitType(self, type, depth=0):
        self.visit(type.value, type.name, depth)

    def visitSum(self, sum, name, depth):
        if is_simple(sum):
            self.simple_sum(sum, name, depth)
        else:
            self.sum_with_constructors(sum, name, depth)

    def simple_sum(self, sum, name, depth):
        enum = []
        for i in range(len(sum.cons)):
            con = sum.cons[i]
            enum.append("k%s=%d" % (con.name, i + 1))
        enums = ", ".join(enum)
        ctype = get_c_type(name)
        s = "enum class %s : uint8_t { %s };" % (ctype, enums)
        self.emit(s, depth)
        self.emit("", depth)

    def typedef(self, name, depth):
        ctype = get_c_type(name)
        self.emit("struct %(name)s_;" % locals(), depth)
        s = "typedef %(name)s_* %(ctype)s;" % locals()
        self.emit(s, depth)
        self.emit("", depth)

    def visitConstructor(self, con, depth):
        self.typedef(con.name, depth)

    def sum_with_constructors(self, sum, name, depth):
        self.typedef(name, depth)
        for c in sum.cons:
            self.visit(c, depth)

    def visitProduct(self, product, name, depth):
        self.typedef(name, depth)


class StructVisitor(EmitVisitor):
    """ Emit abstract struct for complex sums and final struct for products """

    def visitModule(self, mod):
        for type in mod.types:
            self.visit(type)

    def visitType(self, type, depth=0):
        self.visit(type.value, type.name, depth)

    def visitSum(self, sum, name, depth):
        if not is_simple(sum):
            self.sum_with_constructors(sum, name, depth)

    def sum_with_constructors(self, sum, name, depth):
        self.emit_struct(sum.attributes, sum.cons, name, True, depth)

    def emit_struct(self, fields, cons, name, add_visit, depth):
        self.emit("struct %s_ {" % name, depth)
        for f in fields:
            self.visit(f, depth + 1)
        if len(cons) > 0:
            enum = []
            for i in range(len(cons)):
                con = cons[i]
                enum.append("k%s=%d" % (con.name, i + 1))
            enums = ", ".join(enum)
            s = "enum class %sKind : uint8_t { %s } %s_kind;" % (name.title(), enums, name)
            self.emit(s, depth + 1)
        if len(fields) > 0:
            self.emit("", depth)
            args = get_args(fields)
            argstr = ", ".join(["%s %s_" % (atype, aname)
                               for atype, aname, opt in args])
            initstr = ", ".join(["%s(%s_)" % (aname, aname)
                                for atype, aname, opt in args])
            self.emit("%s_(%s) : %s {}" % (name, argstr, initstr), depth + 1)
        if add_visit:
            self.emit("virtual antlrcpp::Any visit(BaseVisitor&) = 0;", depth + 1)
        self.emit("};", depth)
        self.emit("", depth)

    def visitField(self, field, depth):
        ctype = get_c_type(field.type)
        name = field.name
        if field.seq:
            self.emit("std::vector<%(ctype)s> %(name)s;" % locals(), depth)
        else:
            self.emit("%(ctype)s %(name)s;" % locals(), depth)

    def visitProduct(self, product, name, depth):
        self.emit_struct(product.fields + product.attributes, [], name, False, depth)


class BaseVisitorVistor(EmitVisitor):
    """ Emit base visitor class """

    def visitModule(self, mod, depth=0):
        self.emit("class BaseVisitor {", depth)
        self.emit("public:", depth)
        for type in mod.types:
            self.visit(type, False, depth + 1)
        for type in mod.types:
            self.visit(type, True, depth + 1)
        self.emit("};", depth)

    def visitType(self, type, abstracts, depth):
        if not abstracts:
            self.emit("antlrcpp::Any visit(%s_t node) {" % type.name, depth)
            self.visit(type.value, type.name, abstracts, depth + 1)
            self.emit("}", depth)
            self.emit("", depth)
        else:
            self.visit(type.value, type.name, abstracts, depth)

    def visitSum(self, sum, name, abstracts, depth):
        if not abstracts:
            self.emit_sum_function_bodies(sum, name, depth)
        else:
            self.emit_sum_abstracts(sum, name, depth)

    def emit_sum_function_bodies(self, sum, name, depth):
        if is_simple(sum):
            fname = name.title()
            self.emit("return visit%s(node);" % fname, depth)
        else:
            self.emit("return node->visit(*this);", depth)

    def emit_sum_abstracts(self, sum, name, depth):
        if is_simple(sum):
            fname = name.title()
            self.emit("virtual antlrcpp::Any visit%s(%s_t value) = 0;" % (fname, name), depth)
        else:
            for c in sum.cons:
                self.emit_sum_abstract(c, name, depth)

    def emit_sum_abstract(self, cons, type, depth):
        name = cons.name
        self.emit("virtual antlrcpp::Any visit%s(%s_t node) = 0;" % (name, name), depth)

    def visitProduct(self, prod, name, abstracts, depth):
        if not abstracts:
            self.emit_prod_function_bodies(prod, name, depth)
        else:
            self.emit_prod_abstracts(prod, name, depth)
        pass

    def emit_prod_function_bodies(self, prod, name, depth):
        fname = name.title()
        self.emit("return visit%s(node);" % fname, depth)

    def emit_prod_abstracts(self, prod, name, depth):
        fname = name.title()
        self.emit("virtual antlrcpp::Any visit%s(%s_t node) = 0;" % (fname, name), depth)


class InheritanceVisitor(EmitVisitor):
    """ Emit inherited structs for complex sums """

    def visitModule(self, mod):
        for type in mod.types:
            self.visit(type)

    def visitType(self, type, depth=0):
        self.visit(type.value, type.name, depth)

    def visitSum(self, sum, name, depth):
        if not is_simple(sum):
            self.sum_with_constructors(sum, name, depth)

    def sum_with_constructors(self, sum, name, depth):
        for c in sum.cons:
            self.visit(c, sum.attributes, name, depth)

    def visitConstructor(self, cons, attrs, sname, depth):
        self.emit("struct %s_ : %s_ {" % (cons.name, sname), depth)
        for f in cons.fields:
            self.visit(f, depth + 1)
        self.emit("", depth)
        field_args = get_args(cons.fields)
        attr_args = get_args(attrs)
        argstr = ", ".join(["%s %s_" % (atype, aname)
                            for atype, aname, opt in field_args + attr_args])
        initstr = ", ".join(["%s(%s_)" % (aname, aname)
                             for atype, aname, opt in field_args])
        superstr = ", ".join(["%s_" % aname
                              for atype, aname, opt in attr_args])
        initstr = ("%s, %s_(%s)" % (initstr, sname, superstr) if initstr else
                   "%s_(%s)" % (sname, superstr))
        self.emit("%s_(%s) : %s {" % (cons.name, argstr, initstr), depth + 1)
        self.emit("%s_kind = %s_::%sKind::k%s;" %
                  (sname, sname, sname.title(), cons.name), depth + 2)
        self.emit("}", depth + 1)
        self.emit("", depth)
        self.emit("antlrcpp::Any visit(BaseVisitor& v) override {", depth + 1)
        self.emit("return v.visit%s(this);" % cons.name, depth + 2)
        self.emit("}", depth + 1)
        self.emit("", depth)
        self.emit("};", depth)
        self.emit("", depth)

    def visitField(self, field, depth):
        ctype = get_c_type(field.type)
        name = field.name
        if field.seq:
            self.emit("std::vector<%(ctype)s> %(name)s;" % locals(), depth)
        else:
            self.emit("%(ctype)s %(name)s;" % locals(), depth)

    def visitProduct(self, product, name, depth):
        pass


class PrototypeVisitor(EmitVisitor):
    """ Emit constructor prototypes """

    def visitModule(self, mod):
        for type in mod.types:
            self.visit(type)

    def visitType(self, type):
        self.visit(type.value, type.name)

    def visitSum(self, sum, name):
        if is_simple(sum):
            pass
        else:
            for c in sum.cons:
                self.visit(c, name, sum.attributes)

    def visitConstructor(self, cons, type, attrs):
        args = get_args(cons.fields)
        attrs = get_args(attrs)
        ctype = get_c_type(type)
        self.emit_function(cons.name, ctype, args, attrs)

    def emit_function(self, name, ctype, args, attrs):
        args = args + attrs
        argstr = ", ".join(["%s %s" % (atype, aname)
                            for atype, aname, opt in args])
        self.emit("%s %s(%s);" % (ctype, name, argstr), 0)

    def visitProduct(self, prod, name):
        args = get_args(prod.fields)
        attrs = get_args(prod.attributes)
        ctype = get_c_type(name)
        self.emit_function(name, ctype, args, attrs)


class ToStringPrototypeVisitor(EmitVisitor):
    """ Emit to_string() prototypes """

    def visitModule(self, mod):
        for type in mod.types:
            self.visit(type)

    def visitType(self, type, depth=0):
        self.emit("std::string to_string(%s_t node);" % type.name, depth)


class FunctionVisitor(PrototypeVisitor):
    """ Emit constructors """

    def emit_function(self, name, ctype, args, attrs):
        args = args + attrs
        argstr = ", ".join(["%s %s" % (atype, aname)
                            for atype, aname, opt in args])
        self.emit("%s %s(%s) {" % (ctype, name, argstr), 0)
        argstr2 = ", ".join([aname for atype, aname, opt in args])
        self.emit("return new %s_(%s);" % (name, argstr2), 1)
        self.emit("}", 0)
        self.emit("", 0)


class ToStringVisitorVisitor(EmitVisitor):
    """Generate toString visitor"""

    def visitModule(self, mod, depth=0):
        self.emit("class ToStringVisitor : public BaseVisitor {", depth)
        self.emit("""
    std::string to_string(std::string& value) {
        return value;
    }

    template <class T>
    typename std::enable_if<std::is_arithmetic<T>::value, std::string>::type
    to_string(T value) {
        return std::to_string(value);
    }

    template <class T>
    typename std::enable_if<std::is_enum<T>::value, std::string>::type
    to_string(T value) {
        return visit(value).template as<std::string>();
    }

    template <class T>
    std::string to_string(T* value) {
        std::ostringstream oss;
        oss << value;
        return oss.str();
    }

    template <class T>
    std::string to_string(std::vector<T>& values) {
        std::string result = "[";
        if (!values.empty()) {
            result += to_string(values[0]);
            for (size_t i = 1; i < values.size(); i++) {
                result += ", ";
                result += to_string(values[i]);
            }
        }
        result += "]";
        return result;
    }

    template <class T>
    std::string follow(T value) {
        return std::string();
    }

    std::set<void*> already_visited_;

    template <class T>
    std::string follow(T* value) {
        bool placed = already_visited_.insert(value).second;
        return (placed && value) ? visit(value).template as<std::string>()
                                 : std::string();
    }

    template <class T>
    std::string follow(std::vector<T>& values) {
        std::string result;
        for (auto& value: values) {
            result += follow(value);
        }
        return result;
    }

    size_t depth = 0;
    std::string spaces() {
        std::string result = "";
        for (size_t i = 0; i < depth; i++) {
            result += ' ';
        }
        return result;
    }
        """, 0, reflow=False)
        self.emit("public:", depth)
        for type in mod.types:
            self.visit(type, depth + 1)
        self.emit("};", depth)

    def visitType(self, type, depth):
        self.visit(type.value, type.name, depth)

    def visitSum(self, sum, name, depth):
        if is_simple(sum):
            self.simple_sum(sum, name, depth)
        else:
            for c in sum.cons:
                self.visit(c, sum.attributes, name, depth)

    def simple_sum(self, sum, name, depth):
        fname = name.title()
        self.emit("antlrcpp::Any visit%s(%s_t value) override {" % (fname, name), depth)
        self.emit("std::string result;", depth + 1)
        self.emit("switch (value) {", depth + 1)
        for c in sum.cons:
            self.emit("case %s_t::k%s:" % (name, c.name), depth + 2)
            self.emit("result = \"%s\";" % c.name, depth + 3)
            self.emit("break;", depth + 3)
        self.emit("}", depth + 1)
        self.emit("return result;", depth + 1)
        self.emit("}", depth)
        self.emit("", 0)

    def visitConstructor(self, cons, attrs, sname, depth):
        self.emit_function(cons.name, cons.name, cons.fields, attrs, depth)

    def visitProduct(self, product, name, depth):
        self.emit_function(name, name.title(), product.fields, product.attributes, depth)

    def emit_function(self, name, fname, fields, attrs, depth):
        args = get_args(fields + attrs)
        self.emit("antlrcpp::Any visit%s(%s_t node) override {" % (fname, name), depth)
        self.emit("std::string result = spaces() + to_string(node) + \" %s(\";" % name, depth + 1)
        pstr = " + \", \" + ".join(["to_string(node->%s)"
                                    % aname for atype, aname, opt in args])
        if len(pstr) != 0:
            self.emit("result += %s;" % pstr, depth + 1)
        self.emit("result += \")\\n\";", depth + 1)
        self.emit("", 0)
        pstr = " + ".join(["follow(node->%s)" % aname for atype, aname, opt in args])
        if len(pstr) != 0:
            self.emit("depth += 2;", depth + 1)
            self.emit("result += %s;" % pstr, depth + 1)
            self.emit("depth -= 2;", depth + 1)
            self.emit("", 0)
        self.emit("return result;", depth + 1)
        self.emit("}", depth)
        self.emit("", 0)


class ToStringFunctionVisitor(EmitVisitor):
    """ Emit to_string() prototypes """

    def visitModule(self, mod):
        for type in mod.types:
            self.visit(type)

    def visitType(self, type, depth=0):
        self.emit("std::string to_string(%s_t node) {" % type.name, depth)
        self.emit("ToStringVisitor string_visitor;", depth + 1)
        self.emit("return string_visitor.visit(node);", depth + 1)
        self.emit("}", depth)
        self.emit("", 0)


class ChainOfVisitors:
    def __init__(self, *visitors):
        self.visitors = visitors

    def visit(self, object):
        for v in self.visitors:
            v.visit(object)
            v.emit("", 0)


def main(srcfile, output_header, output_file):
    # determine "auto gen" message to appear at top of output
    argv0 = sys.argv[0]
    components = argv0.split(os.sep)
    argv0 = os.sep.join(components[-2:])
    common_msg = "/* File automatically generated by %s. */\n\n"
    auto_gen_msg = common_msg % argv0

    # parse the ASDL file
    mod = asdl.parse(srcfile)
    if not asdl.check(mod):
        sys.exit(1)

    # write the header
    f = open(output_header, "w")
    f.write(auto_gen_msg)
    f.write("#pragma once\n\n")
    f.write('#include <vector>\n')
    f.write('#include <string>\n\n')
    f.write('#include <antlr4-runtime.h>\n\n')
    c = ChainOfVisitors(
                        NamespaceVisitor(f),
                        TypeDefVisitor(f),
                        StructVisitor(f),
                        BaseVisitorVistor(f),
                        InheritanceVisitor(f),
                        PrototypeVisitor(f),
                        ToStringPrototypeVisitor(f),
                        )
    c.visit(mod)
    f.write("}\n")
    f.close()

    # write the output
    f = open(output_file, "w")
    f.write(auto_gen_msg)
    f.write('#include "%s"\n\n' % output_header)
    c = ChainOfVisitors(
                        NamespaceVisitor(f),
                        FunctionVisitor(f),
                        ToStringVisitorVisitor(f),
                        ToStringFunctionVisitor(f),
                       )
    c.visit(mod)
    f.write("}\n")
    f.close()

if __name__ == "__main__":
    import getopt

    # get output options
    output_header = output_file = None
    opts, args = getopt.getopt(sys.argv[1:], "h:c:")
    for o, v in opts:
        if o == '-h':
            output_header = v
        if o == '-c':
            output_file = v

    # ensure the parameters are present
    if not output_header:
        print('Must specify output header')
        sys.exit(1)
    elif not output_file:
        print('Must specify output file')
        sys.exit(1)
    elif len(args) != 1:
        print('Must specify single input file')
        sys.exit(1)

    # run everything
    main(args[0], output_header, output_file)
